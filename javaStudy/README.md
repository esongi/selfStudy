컴파일 기법: 고급언어로 작성된 코드를 기계어로 번역한다음 별도의 확장자로 만들어서 출력하는 방식
인터프리터 기법: 컴퓨터(Central Processing Unit)와 2진코드(기계어)로 1:1 대응하여 출력하는 방식

컴파일 기법: 메모리를 어느정도 먹지만, 속도가 빠르다.
인터프리터 기법: 메모리를 적게 먹지만, 속도가 느리다.

  

복사 https://blog.naver.com/twilight_teatime/221160071839  



<< 웹 프로그래밍 언어 >>
 jsp
 asp
 php


웹프로그래밍 언어 (jsp)의 궁극적인 목적은 어디에 있는가?
 ==> 사용자 요구에 따른 동적인 html을 생성

html 만으로는 정적인 문서밖에 만들지 못한다.
 ==> 어떤 사용자가 접속을 하더라도 매번 똑같은 문서를 서비스한다.

사용자의 상황, 요구에 따라 매번 다른 html을 서비스 하고자 한다.
상황에 따른 그때 그때 다른 html 코드를 생성하려면 ?

 프로그램이 필요하다.
 웹 프로그래밍 언어
 ==> jsp, asp, php 등.
 그중에 jsp.

<< jsp 하고 javascript 의 차이점?? >>

jsp:  서버에서 동작하는 웹프로그래밍 언어
  서버에서 실행해서 생성된 html 을 클라이언트 응답

javascript: 클라이언트에서 동작하는 웹프로그래밍 언어

<< jsp 문장 구성 요소 >>

<% %>
  스크립트릿.
  ==> 온갖 자바 문법이 올 수 있다.


<%= %>
  표현식
  ==> 변수의 내용을 출력하고자 할 때 사용


<%! %>
  선언문
  ==> 변수를 선언하거나 메소드를 정의할 수 있다.


<%@ %>
  지시자
  ==> import 구문등을 기술한다.


** 선언문 안에 변수와 스크립트릿안의 변수는 어떻게 다른가 ???
 ~~~.jsp를 요구하면
 web application server ( WAS == > tomcat )은
 ~~~.java 를 생성하고 ~~~.class 를 생성하여  ( 서블릿)
 서비스 하게 된다.
 선언문 안의 변수는 서블릿 클래스의 맴버변수가 되고
 스크립트릿안의 변수는 서블릿의 실제 일처리를 수행하는 메소드의 지역변수가 된다.

 ex08.jsp 
 ==> ex08_jsp.java
 ==> ex08_jsp.class

<< jsp 지시자 >>

<%@ %>
 jsp 문서를 동작하기 전에 먼저 선행 처리되어야 할 내용을 기술하는 부분.


<%@ page %>
 jsp page의 import 구문 등 page에 필요한 정보를 설정하는 부분.
 사용할 언어, 응답 방식, 인코딩 방식 등을 설정한다.
 import를 가장 많이 사용한다.


<%@ include %>
 이미 만들어진 jsp 문서를 현재 문서에 포함시키고자 할 때 사용.


<%@ taglib %>
 사용자 정의 tag를 설정하기 위한 지시자 


<< jsp 내장객체 >>
 사용자가 별도로 객체를 생성하지 않아도
 jsp 문서가 기본적으로 제공하는 객체

 ==> 사실은 .jsp를 요구하면 web application server (WAS) 가 할일이 많다.
  --.java 도 만들고 그것을 컴파일도 해야 합니다. (--.class)
  그 컴파일된 클래스를 가지고 서비스합니다.

  그 생성된 서블릿클래스 속을 들여 보면
  실제 서비스를 하는 메소드가 있는데
  그 메소드의 매개변수와 그 메소드안에서 정의한
  지역변수들이 바로 jsp  내장 객체들이다.!!!

  request  : 사용자의 요청 정보를 담고 있는 객체
  response : 사용자에게 응답을 위한 객체

  session  : 

  application

  out

  exception **

* Java SE (Java platform Standard Edition, J2SE 업그레이드 버전)
   - 가장 널리 쓰이는 자바 핵심 라이브러리 및 API 집합체
   - 데스크톱, 서버, 임베디드시스템 등을 위한 표준 자바 플랫폼에서 사용
      (Java EE, ME 는 목적에 따라 SE를 기반으로 기존의 일부를 택하거나 추가하여 구성된 것)

* Java EE (Java platform Enterprise Edition, J2EE 업그레이드 버전)
   - JAVA를 이용한 Server side(서버 측) 개발을 위한 플랫폼
   - Enterprise 환경을 위한 EJB, JSP, Servlet, JNDI 같은 기능 지원
   - WAS를 이용하는 프로그램 개발 시 사용됨   
- 응용 프로그램(ex. 웹 어플리케이션) 서버에서 장애 복구, 분산 멀티미디어, 다중 계층 등의 자바           소프트웨어 기능을 제공 (응용 프로그램에서 큰 규모의 분산 시스템이 필요한 경우 사용)

* Java ME (Java platform Micro Edition, J2ME 업그레이드 버전) 
   - 임베디드 시스템 개발을 위한 플랫폼(모바일, PDA, 셋톱 박스 등) 에서 사용
   - 과거 Java SE 버전을 기반으로 하기 때문에 자바 1.5 부터 도입된 기능 중 일부(ex. generic)는
     미포함

일단 결론: 
' == ' 참조값을 비교한다
' equals ' 내용을 비교한다


equals(Object obj)
오브젝트 객체가 파라미터에 있는 객체와 
"같은"지를 분석해 Boolean으로 리턴한다.
(같으면 true,다르면 false)

그렇다면, ==비교와 equals비교의 차이는 무엇일까요?
 우선 ==비교와 equals메서드의 차이는 없습니다. Object 클래스에 한해서는 말이죠!
Object 클래스에서도 결국엔 ==으로 비교하고 이 값을 리턴해주고 있습니다.
그렇다면 우리는 어째서
"korean"==new String("korean")
과 "korean".equals(new String("korean")에서 다른 Boolean값을 받고 있는 걸까요?

맨 처음 언급했던 오버라이딩(Override)의 놀라운 모습중 하나라고 생각합니다.
먼저 '=='연산자는 값의 위치를 비교합니다.
일반적으로 자바에서는 변수의 메모리를 할당할때 값이 같다면 같은 메모리에 할당합니다.
int k =7;
int kris =7;
이 두변수는 같은 참조값을 가지기 때문에 
k==kris 이 비교는 true를 리턴하겠지요.


------------------------------------------

여러분들도 아시다시피 자바에서는 문자열은 String 변수에 저장하며,

아래와 같은 방식으로 String 변수에 문자열 리터럴을 대입합니다.

※ 여기서 잠깐!

리터럴(literal): 소스 코드의 고정된 값을 대표하는 용어, 통상적으로는 상수와 같은 의미로 

사용되기는 하나 상수와 미묘한 차이가 존재함.

상수는 "변수의 상대적인 의미로서 값을 수정할 수 없는 변수"라는 뜻을 가지고 있고, 리터럴은 

"값 그 자체"라는 의미가 강함.

ex) 문자열 리터럴: "안녕하세요!", 정수 리터럴: 100




사실 문자열을 String 변수에 저장한다는 말은 틀린 표현이며,

문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String 객체로 생성되고

변수는 String 객체를 참조합니다.

String도 앞선 포스팅에서 설명하였던 참조 변수이기 때문이죠!

String str = "JAVA";
String str2 = "String";

String str = "JAVA";
String str2 = "JAVA";
// 내용이 같을 경우 같은 참조값을 가리킨다.

또한, 첫 번째 그림의 경우에서는 str == str2의 연산 결과는 false이고,
두 번째 그림의 경우에서는 str == str2의 연산 결과는 true가 나옵니다.

변수는 stack 영역에 생성
하지만 값은 heap 영역에 생성
변수는 값의 주소를 참조한다.

- new 연산자와 String
new 연산자는 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 합니다.
String에서 new 연산자를 언급한 이유는 문자열 리터럴로 생성하느냐 new 연산자로 생성하느냐에 따라
비교 연산자의 결과가 달라질 수 있다는 것입니다.

String str = new String("JAVA");
String str2 = new String("JAVA");

문자열 리터럴로 생성할 때와 다르게 똑같은 문자임에도 불구하고
두 String 변수가 똑같은 객체를 참조하지 않습니다. 
즉, 위의 경우에 str == str2의 연산 결과는 false가 나온다는 뜻입니다.


- equals() 메소드
문자열 리터럴로 String을 생성한 경우와 new 연산자로 String을 생성한 경우에서
'==' 연산자의 연산 결과 차이를 알아보았습니다. 
new 연산자로 String을 생성한 경우에서 '==' 연산자를 쓰면 같은 문자임에도 불구하고
false가 나오는 문제가 생길 수 있습니다. 
이럴 때는 String 객체의 equals() 메소드를 사용해야 합니다.
equals() 메소드는 동일한 String 객체이건 다른 String 객체이건 상관없이 문자열만을 비교해줍니다.
equals() 메소드는 원본 문자열과 매개값으로 주어진 비교 문자열이 
동일한지 비교한 후 true 또는 false를 리턴합니다.

// 처음 생성한 example 이라는 문자열은 그대로 남아있고
// 다시 선언한 문자열을 생성한다는 것이 불변의 속성.
// 그래서 처음에 생성한 인스턴스는 gc(가비지컬렉션)이 회수한다





